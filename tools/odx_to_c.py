#!/usr/bin/env python3
"""
ODX-to-C Code Generator for LibUDS

Parses ODX (Open Diagnostic Data Exchange) files and generates:
- uds_did_table.c: DID registry with read/write permissions
- uds_did_table.h: Header declarations

Usage:
    python odx_to_c.py input.odx --output src/generated/
"""

import argparse
import sys
from pathlib import Path
from typing import List, Dict
import xml.etree.ElementTree as ET

# Template for generated C header
HEADER_TEMPLATE = '''/**
 * @file uds_did_table.h
 * @brief Auto-generated DID table from ODX
 * 
 * Generated by odx_to_c.py
 * DO NOT EDIT MANUALLY
 */

#ifndef UDS_DID_TABLE_H
#define UDS_DID_TABLE_H

#include "uds/uds_types.h"

extern const uds_did_entry_t generated_did_table[];
extern const uint16_t generated_did_table_count;

#endif /* UDS_DID_TABLE_H */
'''

# Template for generated C source
SOURCE_TEMPLATE = '''/**
 * @file uds_did_table.c
 * @brief Auto-generated DID table from ODX
 * 
 * Generated by odx_to_c.py from: {odx_file}
 * DO NOT EDIT MANUALLY
 */

#include "uds_did_table.h"

const uds_did_entry_t generated_did_table[] = {{
{did_entries}
}};

const uint16_t generated_did_table_count = sizeof(generated_did_table) / sizeof(generated_did_table[0]);
'''


class ODXParser:
    """Minimal ODX parser for DID extraction"""
    
    def __init__(self, odx_file: Path):
        self.odx_file = odx_file
        self.tree = ET.parse(odx_file)
        self.root = self.tree.getroot()
        # ODX uses namespaces, we'll handle both with and without
        
    def extract_dids(self) -> List[Dict]:
        """Extract DIDs from ODX"""
        dids = []
        
        # Try to find DIDs in common ODX structures
        # Note: Real ODX files have complex namespaces, this is simplified
        for elem in self.root.iter():
            # Look for DATA-OBJECT-PROP or similar
            if 'DATA-OBJECT-PROP' in elem.tag or 'DIAG-DATA-DICTIONARY' in elem.tag:
                did_id = self._extract_id(elem)
                if did_id is not None:
                    did_info = {
                        'id': did_id,
                        'length': self._extract_length(elem),
                        'name': self._extract_name(elem),
                        'readable': True,  # Default assumptions
                        'writable': False,
                    }
                    dids.append(did_info)
        
        return dids
    
    def _extract_id(self, elem) -> int:
        """Extract DID identifier"""
        # Look for ID element
        for child in elem:
            if 'ID' in child.tag and child.text:
                try:
                    # Handle hex format
                    if child.text.startswith('0x'):
                        return int(child.text, 16)
                    return int(child.text)
                except ValueError:
                    pass
        return None
    
    def _extract_length(self, elem) -> int:
        """Extract byte length"""
        for child in elem.iter():
            if 'BIT-LENGTH' in child.tag and child.text:
                try:
                    bit_len = int(child.text)
                    return (bit_len + 7) // 8  # Convert to bytes
                except ValueError:
                    pass
        return 0  # Unknown length
    
    def _extract_name(self, elem) -> str:
        """Extract DID name"""
        for child in elem:
            if 'SHORT-NAME' in child.tag and child.text:
                return child.text
        return "UNKNOWN"


def generate_c_code(dids: List[Dict], odx_file: str) -> tuple:
    """Generate C header and source code"""
    
    # Generate DID entries
    did_entries = []
    for did in dids:
        # Format: {id, length, flags, fn_read, fn_write}
        flags = "DID_READ" if did['readable'] else "0"
        if did['writable']:
            flags += " | DID_WRITE"
        
        entry = f"    {{0x{did['id']:04X}, {did['length']:2d}, {flags:20s}, NULL, NULL}},  // {did['name']}"
        did_entries.append(entry)
    
    source = SOURCE_TEMPLATE.format(
        odx_file=odx_file,
        did_entries='\n'.join(did_entries)
    )
    
    return HEADER_TEMPLATE, source


def main():
    parser = argparse.ArgumentParser(description='Generate C code from ODX files')
    parser.add_argument('odx_file', type=Path, help='Input ODX file')
    parser.add_argument('--output', type=Path, default=Path('.'), help='Output directory')
    parser.add_argument('--verify', action='store_true', help='Verify mode (check for drift)')
    
    args = parser.parse_args()
    
    if not args.odx_file.exists():
        print(f"Error: ODX file not found: {args.odx_file}", file=sys.stderr)
        return 1
    
    print(f"Parsing ODX file: {args.odx_file}")
    
    try:
        odx = ODXParser(args.odx_file)
        dids = odx.extract_dids()
        
        if not dids:
            print("Warning: No DIDs found in ODX file", file=sys.stderr)
            print("This is a minimal parser. For production use, consider 'odxtools' library.")
            return 0
        
        print(f"Found {len(dids)} DIDs")
        
        header, source = generate_c_code(dids, str(args.odx_file))
        
        # Write output files
        args.output.mkdir(parents=True, exist_ok=True)
        
        header_path = args.output / 'uds_did_table.h'
        source_path = args.output / 'uds_did_table.c'
        
        if args.verify:
            # Verify mode: check if files match
            if header_path.exists() and source_path.exists():
                existing_source = source_path.read_text()
                if existing_source.strip() == source.strip():
                    print("✅ Generated code matches existing files")
                    return 0
                else:
                    print("❌ Generated code differs from existing files", file=sys.stderr)
                    return 1
            else:
                print("❌ Output files do not exist", file=sys.stderr)
                return 1
        
        header_path.write_text(header)
        source_path.write_text(source)
        
        print(f"✅ Generated: {header_path}")
        print(f"✅ Generated: {source_path}")
        print(f"\nTo use: Add {source_path} to your build and include {header_path}")
        
        return 0
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
